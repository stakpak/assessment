{
  "provider": {
    "helm": {
      "kubernetes": {
        "config_path": "~/.kube/config"
      }
    }
  },
  "resource": {
    "helm_release": {
      "rabbitmqop": {
        "name": "rabbitmqop",
        "namespace": "rabbitmq",
        "repository": "oci://registry-1.docker.io/bitnamicharts",
        "chart": "rabbitmq-cluster-operator",
        "version": "3.4.1",
        "timeout": 600,
        "atomic": true,
        "create_namespace": true,
        "values": [
          "global:\n  imageRegistry: \"\"\n  imagePullSecrets: []\n  storageClass: \"\"\nkubeVersion: \"\"\nnameOverride: \"\"\nfullnameOverride: \"\"\ncommonLabels: {}\ncommonAnnotations: {}\nclusterDomain: cluster.local\nextraDeploy: []\ndiagnosticMode:\n  enabled: false\nrabbitmqImage:\n  registry: docker.io\n  repository: bitnami/rabbitmq\n  tag: 3.11.16-debian-11-r3\n  digest: \"\"\n  pullSecrets: []\ncredentialUpdaterImage:\n  registry: docker.io\n  repository: bitnami/rmq-default-credential-updater\n  tag: 1.0.2-scratch-r21\n  digest: \"\"\n  pullSecrets: []\nclusterOperator:\n  image:\n    registry: docker.io\n    repository: bitnami/rabbitmq-cluster-operator\n    tag: 2.2.0-scratch-r7\n    digest: \"\"\n    pullPolicy: IfNotPresent\n    pullSecrets: []\n  replicaCount: 1\n  topologySpreadConstraints: []\n  schedulerName: \"\"\n  terminationGracePeriodSeconds: \"\"\n  livenessProbe:\n    enabled: true\n    initialDelaySeconds: 5\n    periodSeconds: 30\n    timeoutSeconds: 5\n    successThreshold: 1\n    failureThreshold: 5\n  readinessProbe:\n    enabled: true\n    initialDelaySeconds: 5\n    periodSeconds: 30\n    timeoutSeconds: 5\n    successThreshold: 1\n    failureThreshold: 5\n  startupProbe:\n    enabled: false\n    initialDelaySeconds: 5\n    periodSeconds: 30\n    timeoutSeconds: 5\n    successThreshold: 1\n    failureThreshold: 5\n  customLivenessProbe: {}\n  customReadinessProbe: {}\n  customStartupProbe: {}\n  resources:\n    limits: {}\n    requests: {}\n  podSecurityContext:\n    enabled: true\n    fsGroup: 1001\n  containerSecurityContext:\n    enabled: true\n    runAsUser: 1001\n    runAsNonRoot: true\n    readOnlyRootFilesystem: true\n  command: []\n  args: []\n  hostAliases: []\n  podLabels: {}\n  podAnnotations: {}\n  podAffinityPreset: \"\"\n  podAntiAffinityPreset: soft\n  nodeAffinityPreset: {}\n  affinity: {}\n  nodeSelector: {}\n  tolerations: []\n  updateStrategy:\n    type: RollingUpdate\n  priorityClassName: \"\"\n  lifecycleHooks: {}\n  containerPorts:\n    metrics: 9782\n  extraEnvVars: []\n  extraEnvVarsCM: \"\"\n  extraEnvVarsSecret: \"\"\n  extraVolumes: []\n  extraVolumeMounts: []\n  sidecars: []\n  initContainers: []\n  rbac:\n    create: true\n  serviceAccount:\n    create: true\n    annotations: {}\n    extraLabels: {}\n    name: \"\"\n    automountServiceAccountToken: true\n  metrics:\n    service:\n      enabled: false\n      type: ClusterIP\n      port: 80\n      nodePorts:\n        http: \"\"\n      clusterIP: \"\"\n      extraPorts: []\n      loadBalancerIP: \"\"\n      loadBalancerSourceRanges: []\n      externalTrafficPolicy: Cluster\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: 80\n      sessionAffinity: None\n      sessionAffinityConfig: {}\n      serviceMonitor:\n        enabled: false\n        jobLabel: app.kubernetes.io/name\n        honorLabels: false\n        selector: {}\n        scrapeTimeout: \"\"\n        interval: \"\"\n        metricRelabelings: []\n        relabelings: []\n        labels: {}\nmsgTopologyOperator:\n  image:\n    registry: docker.io\n    repository: bitnami/rmq-messaging-topology-operator\n    tag: 1.10.3-scratch-r1\n    digest: \"\"\n    pullPolicy: IfNotPresent\n    pullSecrets: []\n  replicaCount: 1\n  topologySpreadConstraints: []\n  schedulerName: \"\"\n  terminationGracePeriodSeconds: \"\"\n  hostNetwork: \"false\"\n  dnsPolicy: ClusterFirst\n  livenessProbe:\n    enabled: true\n    initialDelaySeconds: 5\n    periodSeconds: 30\n    timeoutSeconds: 5\n    successThreshold: 1\n    failureThreshold: 5\n  readinessProbe:\n    enabled: true\n    initialDelaySeconds: 5\n    periodSeconds: 30\n    timeoutSeconds: 5\n    successThreshold: 1\n    failureThreshold: 5\n  startupProbe:\n    enabled: false\n    initialDelaySeconds: 5\n    periodSeconds: 30\n    timeoutSeconds: 5\n    successThreshold: 1\n    failureThreshold: 5\n  customLivenessProbe: {}\n  customReadinessProbe: {}\n  customStartupProbe: {}\n  existingWebhookCertSecret: \"\"\n  existingWebhookCertCABundle: \"\"\n  resources:\n    limits: {}\n    requests: {}\n  podSecurityContext:\n    enabled: true\n    fsGroup: 1001\n  containerSecurityContext:\n    enabled: true\n    runAsUser: 1001\n    runAsNonRoot: true\n    readOnlyRootFilesystem: true\n  command: []\n  args: []\n  fullnameOverride: \"\"\n  hostAliases: []\n  podLabels: {}\n  podAnnotations: {}\n  podAffinityPreset: \"\"\n  podAntiAffinityPreset: soft\n  nodeAffinityPreset: {}\n  affinity: {}\n  nodeSelector: {}\n  tolerations: []\n  updateStrategy:\n    type: RollingUpdate\n  priorityClassName: \"\"\n  lifecycleHooks: {}\n  containerPorts:\n    metrics: 8080\n  extraEnvVars: []\n  extraEnvVarsCM: \"\"\n  extraEnvVarsSecret: \"\"\n  extraVolumes: []\n  extraVolumeMounts: []\n  sidecars: []\n  initContainers: []\n  rbac:\n    create: true\n  serviceAccount:\n    create: true\n    annotations: {}\n    extraLabels: {}\n    name: \"\"\n    automountServiceAccountToken: true\n  metrics:\n    service:\n      enabled: false\n      type: ClusterIP\n      port: 80\n      nodePorts:\n        http: \"\"\n      clusterIP: \"\"\n      extraPorts: []\n      loadBalancerIP: \"\"\n      loadBalancerSourceRanges: []\n      externalTrafficPolicy: Cluster\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: 80\n      sessionAffinity: None\n      sessionAffinityConfig: {}\n      serviceMonitor:\n        enabled: false\n        jobLabel: app.kubernetes.io/name\n        honorLabels: false\n        selector: {}\n        scrapeTimeout: \"\"\n        interval: \"\"\n        metricRelabelings: []\n        relabelings: []\n        labels: {}\n  service:\n    type: ClusterIP\n    ports:\n      webhook: 443\n    nodePorts:\n      http: \"\"\n    clusterIP: \"\"\n    loadBalancerIP: \"\"\n    extraPorts: []\n    loadBalancerSourceRanges: []\n    externalTrafficPolicy: Cluster\n    annotations: {}\n    sessionAffinity: None\n    sessionAffinityConfig: {}\nuseCertManager: false\n"
        ],
        "depends_on": []
      },
      "kedaop": {
        "name": "kedaop",
        "namespace": "keda",
        "repository": "https://kedacore.github.io/charts",
        "chart": "keda",
        "version": "2.12.0",
        "timeout": 600,
        "atomic": true,
        "create_namespace": true,
        "values": [
          "image:\n  keda:\n    repository: ghcr.io/kedacore/keda\n    tag: \"\"\n  metricsApiServer:\n    repository: ghcr.io/kedacore/keda-metrics-apiserver\n    tag: \"\"\n  webhooks:\n    repository: ghcr.io/kedacore/keda-admission-webhooks\n    tag: \"\"\n  pullPolicy: IfNotPresent\nclusterDomain: cluster.local\ncrds:\n  install: true\nwatchNamespace: \"\"\nimagePullSecrets: []\noperator:\n  name: keda-operator\n  revisionHistoryLimit: 10\n  replicaCount: 1\n  affinity: {}\n  livenessProbe:\n    initialDelaySeconds: 25\n    periodSeconds: 10\n    timeoutSeconds: 1\n    failureThreshold: 3\n    successThreshold: 1\n  readinessProbe:\n    initialDelaySeconds: 20\n    periodSeconds: 3\n    timeoutSeconds: 1\n    failureThreshold: 3\n    successThreshold: 1\nmetricsServer:\n  revisionHistoryLimit: 10\n  replicaCount: 1\n  dnsPolicy: ClusterFirst\n  useHostNetwork: false\n  affinity: {}\n  livenessProbe:\n    initialDelaySeconds: 5\n    periodSeconds: 10\n    timeoutSeconds: 1\n    failureThreshold: 3\n    successThreshold: 1\n  readinessProbe:\n    initialDelaySeconds: 5\n    periodSeconds: 3\n    timeoutSeconds: 1\n    failureThreshold: 3\n    successThreshold: 1\nwebhooks:\n  name: keda-admission-webhooks\n  enabled: true\n  port: 9443\n  healthProbePort: 8081\n  livenessProbe:\n    initialDelaySeconds: 25\n    periodSeconds: 10\n    timeoutSeconds: 1\n    failureThreshold: 3\n    successThreshold: 1\n  readinessProbe:\n    initialDelaySeconds: 20\n    periodSeconds: 3\n    timeoutSeconds: 1\n    failureThreshold: 3\n    successThreshold: 1\n  useHostNetwork: false\n  revisionHistoryLimit: 10\n  replicaCount: 1\n  affinity: {}\n  failurePolicy: Ignore\nupdateStrategy:\n  operator: {}\n  metricsApiServer: {}\n  webhooks: {}\npodDisruptionBudget:\n  operator: {}\n  metricServer: {}\n  webhooks: {}\nadditionalLabels: {}\nadditionalAnnotations: {}\npodAnnotations:\n  keda: {}\n  metricsAdapter: {}\n  webhooks: {}\npodLabels:\n  keda: {}\n  metricsAdapter: {}\n  webhooks: {}\nrbac:\n  create: true\n  aggregateToDefaultRoles: false\nserviceAccount:\n  create: true\n  name: keda-operator\n  automountServiceAccountToken: true\n  annotations: {}\npodIdentity:\n  activeDirectory:\n    identity: \"\"\n  azureWorkload:\n    enabled: false\n    clientId: \"\"\n    tenantId: \"\"\n    tokenExpiration: 3600\n  aws:\n    irsa:\n      enabled: false\n      audience: sts.amazonaws.com\n      roleArn: \"\"\n      stsRegionalEndpoints: true\n      tokenExpiration: 3600\n  gcp:\n    enabled: false\n    gcpIAMServiceAccount: \"\"\ngrpcTLSCertsSecret: \"\"\nhashiCorpVaultTLS: \"\"\nlogging:\n  operator:\n    level: info\n    format: console\n    timeEncoding: rfc3339\n  metricServer:\n    level: \"0\"\n  webhooks:\n    level: info\n    format: console\n    timeEncoding: rfc3339\nsecurityContext:\n  operator:\n    capabilities:\n      drop:\n        - ALL\n    allowPrivilegeEscalation: false\n    readOnlyRootFilesystem: true\n    seccompProfile:\n      type: RuntimeDefault\n  metricServer:\n    capabilities:\n      drop:\n        - ALL\n    allowPrivilegeEscalation: false\n    readOnlyRootFilesystem: true\n    seccompProfile:\n      type: RuntimeDefault\n  webhooks:\n    capabilities:\n      drop:\n        - ALL\n    allowPrivilegeEscalation: false\n    readOnlyRootFilesystem: true\n    seccompProfile:\n      type: RuntimeDefault\npodSecurityContext:\n  operator:\n    runAsNonRoot: true\n  metricServer:\n    runAsNonRoot: true\n  webhooks:\n    runAsNonRoot: true\nserivce:\n  type: ClusterIP\n  portHttps: 443\n  portHttpsTarget: 6443\n  annotations: {}\nresources:\n  operator:\n    limits:\n      cpu: \"1\"\n      memory: 1000Mi\n    requests:\n      cpu: 100m\n      memory: 100Mi\n  metricServer:\n    limits:\n      cpu: \"1\"\n      memory: 1000Mi\n    requests:\n      cpu: 100m\n      memory: 100Mi\n  webhooks:\n    limits:\n      cpu: 50m\n      memory: 100Mi\n    requests:\n      cpu: 10m\n      memory: 10Mi\nnodeSelector: {}\ntolerations: []\ntopologySpreadConstraints:\n  operator: []\n  metricsServer: []\n  webhooks: []\naffinity: {}\npriorityClassName: \"\"\nhttp:\n  timeout: 3000\n  keepAlive:\n    enabled: true\n  minTlsVersion: TLS12\nextraArgs:\n  keda: {}\n  metricsAdapter: {}\nenv: []\nvolumes:\n  keda:\n    extraVolumes: []\n    extraVolumeMounts: []\n  metricsApiServer:\n    extraVolumes: []\n    extraVolumeMounts: []\n  webhooks:\n    extraVolumes: []\n    extraVolumeMounts: []\nprometheus:\n  metricServer:\n    enabled: false\n    port: 8080\n    portName: metrics\n    serviceMonitor:\n      enabled: false\n      jobLabel: \"\"\n      targetLabels: []\n      podTargetLabels: []\n      port: metrics\n      targetPort: \"\"\n      interval: \"\"\n      scrapeTimeout: \"\"\n      relabellings: []\n      relabelings: []\n      additionalLabels: {}\n    podMonitor:\n      enabled: false\n      interval: \"\"\n      scrapeTimeout: \"\"\n      namespace: \"\"\n      additionalLabels: {}\n      relabelings: []\n  operator:\n    enabled: false\n    port: 8080\n    serviceMonitor:\n      enabled: false\n      jobLabel: \"\"\n      targetLabels: []\n      podTargetLabels: []\n      port: metrics\n      targetPort: \"\"\n      interval: \"\"\n      scrapeTimeout: \"\"\n      relabellings: []\n      relabelings: []\n      additionalLabels: {}\n    podMonitor:\n      enabled: false\n      interval: \"\"\n      scrapeTimeout: \"\"\n      namespace: \"\"\n      additionalLabels: {}\n      relabelings: []\n    prometheusRules:\n      enabled: false\n      namespace: \"\"\n      additionalLabels: {}\n      alerts: []\n  webhooks:\n    enabled: false\n    port: 8080\n    serviceMonitor:\n      enabled: false\n      jobLabel: \"\"\n      targetLabels: []\n      podTargetLabels: []\n      port: metrics\n      targetPort: \"\"\n      interval: \"\"\n      scrapeTimeout: \"\"\n      relabellings: []\n      relabelings: []\n      additionalLabels: {}\n    prometheusRules:\n      enabled: false\n      namespace: \"\"\n      additionalLabels: {}\n      alerts: []\nopentelemetry:\n  collector:\n    uri: \"\"\n  operator:\n    enabled: false\ncertificates:\n  autoGenerated: true\n  secretName: kedaorg-certs\n  mountPath: /certs\n  certManager:\n    enabled: false\n    generateCA: true\n    caSecretName: kedaorg-ca\n    secretTemplate:\n      annotations: {}\n      labels: {}\npermissions:\n  metricServer:\n    restrict:\n      secret: false\n  operator:\n    restrict:\n      secret: false\nextraObjects: []\nasciiArt: true\n"
        ],
        "depends_on": []
      },
      "ingress": {
        "name": "ingress",
        "namespace": "ingress-nginx",
        "repository": "https://kubernetes.github.io/ingress-nginx",
        "chart": "ingress-nginx",
        "version": "4.0.5",
        "timeout": 600,
        "atomic": true,
        "create_namespace": true,
        "values": [
          "{}\n"
        ],
        "depends_on": ["helm_release.metallb"]
      },
      "metallb": {
        "name": "metallb",
        "namespace": "metallb-system",
        "repository": "https://metallb.github.io/metallb",
        "chart": "metallb",
        "timeout": 600,
        "atomic": true,
        "create_namespace": true,
        "values": [
          "{}\n"
        ],
        "depends_on": []
      }
    }
  }
}